import { PaymentError } from "./PaymentError.mjs";
import { USER_AGENT } from "../../client.mjs";
import { BillingKeyClient } from "./billingKey/client.mjs";
import { CashReceiptClient } from "./cashReceipt/client.mjs";
import { PaymentScheduleClient } from "./paymentSchedule/client.mjs";
import { PromotionClient } from "./promotion/client.mjs";
export function PaymentClient(init) {
  const baseUrl = init.baseUrl ?? "https://api.portone.io";
  const secret = init.secret;
  return {
    preRegisterPayment: async (options) => {
      const {
        paymentId,
        storeId,
        totalAmount,
        taxFreeAmount,
        currency
      } = options;
      const requestBody = JSON.stringify({
        storeId: storeId ?? init.storeId,
        totalAmount,
        taxFreeAmount,
        currency
      });
      const response = await fetch(
        new URL(`/payments/${encodeURIComponent(paymentId)}/pre-register`, baseUrl),
        {
          method: "POST",
          headers: {
            Authorization: `PortOne ${secret}`,
            "User-Agent": USER_AGENT
          },
          body: requestBody
        }
      );
      if (!response.ok) {
        throw new PreRegisterPaymentError(await response.json());
      }
      return response.json();
    },
    getPayment: async (options) => {
      const {
        paymentId,
        storeId
      } = options;
      const query = [
        ["storeId", storeId]
      ].flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`).join("&");
      const response = await fetch(
        new URL(`/payments/${encodeURIComponent(paymentId)}?${query}`, baseUrl),
        {
          method: "GET",
          headers: {
            Authorization: `PortOne ${secret}`,
            "User-Agent": USER_AGENT
          }
        }
      );
      if (!response.ok) {
        throw new GetPaymentError(await response.json());
      }
      return response.json();
    },
    getPayments: async (options) => {
      const page = options?.page;
      const filter = options?.filter;
      const requestBody = JSON.stringify({
        page,
        filter
      });
      const query = [
        ["requestBody", requestBody]
      ].flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`).join("&");
      const response = await fetch(
        new URL(`/payments?${query}`, baseUrl),
        {
          method: "GET",
          headers: {
            Authorization: `PortOne ${secret}`,
            "User-Agent": USER_AGENT
          }
        }
      );
      if (!response.ok) {
        throw new GetPaymentsError(await response.json());
      }
      return response.json();
    },
    getAllPaymentsByCursor: async (options) => {
      const storeId = options?.storeId;
      const from = options?.from;
      const until = options?.until;
      const cursor = options?.cursor;
      const size = options?.size;
      const requestBody = JSON.stringify({
        storeId: storeId ?? init.storeId,
        from,
        until,
        cursor,
        size
      });
      const query = [
        ["requestBody", requestBody]
      ].flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`).join("&");
      const response = await fetch(
        new URL(`/payments-by-cursor?${query}`, baseUrl),
        {
          method: "GET",
          headers: {
            Authorization: `PortOne ${secret}`,
            "User-Agent": USER_AGENT
          }
        }
      );
      if (!response.ok) {
        throw new GetAllPaymentsError(await response.json());
      }
      return response.json();
    },
    cancelPayment: async (options) => {
      const {
        paymentId,
        storeId,
        amount,
        taxFreeAmount,
        vatAmount,
        reason,
        requester,
        currentCancellableAmount,
        refundAccount
      } = options;
      const requestBody = JSON.stringify({
        storeId: storeId ?? init.storeId,
        amount,
        taxFreeAmount,
        vatAmount,
        reason,
        requester,
        currentCancellableAmount,
        refundAccount
      });
      const response = await fetch(
        new URL(`/payments/${encodeURIComponent(paymentId)}/cancel`, baseUrl),
        {
          method: "POST",
          headers: {
            Authorization: `PortOne ${secret}`,
            "User-Agent": USER_AGENT
          },
          body: requestBody
        }
      );
      if (!response.ok) {
        throw new CancelPaymentError(await response.json());
      }
      return response.json();
    },
    payWithBillingKey: async (options) => {
      const {
        paymentId,
        storeId,
        billingKey,
        channelKey,
        orderName,
        customer,
        customData,
        amount,
        currency,
        installmentMonth,
        useFreeInterestFromMerchant,
        useCardPoint,
        cashReceipt,
        country,
        noticeUrls,
        products,
        productCount,
        productType,
        shippingAddress,
        promotionId,
        bypass
      } = options;
      const requestBody = JSON.stringify({
        storeId: storeId ?? init.storeId,
        billingKey,
        channelKey,
        orderName,
        customer,
        customData,
        amount,
        currency,
        installmentMonth,
        useFreeInterestFromMerchant,
        useCardPoint,
        cashReceipt,
        country,
        noticeUrls,
        products,
        productCount,
        productType,
        shippingAddress,
        promotionId,
        bypass
      });
      const response = await fetch(
        new URL(`/payments/${encodeURIComponent(paymentId)}/billing-key`, baseUrl),
        {
          method: "POST",
          headers: {
            Authorization: `PortOne ${secret}`,
            "User-Agent": USER_AGENT
          },
          body: requestBody
        }
      );
      if (!response.ok) {
        throw new PayWithBillingKeyError(await response.json());
      }
      return response.json();
    },
    payInstantly: async (options) => {
      const {
        paymentId,
        storeId,
        channelKey,
        channelGroupId,
        method,
        orderName,
        isCulturalExpense,
        isEscrow,
        customer,
        customData,
        amount,
        currency,
        country,
        noticeUrls,
        products,
        productCount,
        productType,
        shippingAddress,
        promotionId
      } = options;
      const requestBody = JSON.stringify({
        storeId: storeId ?? init.storeId,
        channelKey,
        channelGroupId,
        method,
        orderName,
        isCulturalExpense,
        isEscrow,
        customer,
        customData,
        amount,
        currency,
        country,
        noticeUrls,
        products,
        productCount,
        productType,
        shippingAddress,
        promotionId
      });
      const response = await fetch(
        new URL(`/payments/${encodeURIComponent(paymentId)}/instant`, baseUrl),
        {
          method: "POST",
          headers: {
            Authorization: `PortOne ${secret}`,
            "User-Agent": USER_AGENT
          },
          body: requestBody
        }
      );
      if (!response.ok) {
        throw new PayInstantlyError(await response.json());
      }
      return response.json();
    },
    closeVirtualAccount: async (options) => {
      const {
        paymentId,
        storeId
      } = options;
      const query = [
        ["storeId", storeId]
      ].flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`).join("&");
      const response = await fetch(
        new URL(`/payments/${encodeURIComponent(paymentId)}/virtual-account/close?${query}`, baseUrl),
        {
          method: "POST",
          headers: {
            Authorization: `PortOne ${secret}`,
            "User-Agent": USER_AGENT
          }
        }
      );
      if (!response.ok) {
        throw new CloseVirtualAccountError(await response.json());
      }
      return response.json();
    },
    applyEscrowLogistics: async (options) => {
      const {
        paymentId,
        storeId,
        sender,
        receiver,
        logistics,
        sendEmail,
        products
      } = options;
      const requestBody = JSON.stringify({
        storeId: storeId ?? init.storeId,
        sender,
        receiver,
        logistics,
        sendEmail,
        products
      });
      const response = await fetch(
        new URL(`/payments/${encodeURIComponent(paymentId)}/escrow/logistics`, baseUrl),
        {
          method: "POST",
          headers: {
            Authorization: `PortOne ${secret}`,
            "User-Agent": USER_AGENT
          },
          body: requestBody
        }
      );
      if (!response.ok) {
        throw new ApplyEscrowLogisticsError(await response.json());
      }
      return response.json();
    },
    modifyEscrowLogistics: async (options) => {
      const {
        paymentId,
        storeId,
        sender,
        receiver,
        logistics,
        sendEmail,
        products
      } = options;
      const requestBody = JSON.stringify({
        storeId: storeId ?? init.storeId,
        sender,
        receiver,
        logistics,
        sendEmail,
        products
      });
      const response = await fetch(
        new URL(`/payments/${encodeURIComponent(paymentId)}/escrow/logistics`, baseUrl),
        {
          method: "PATCH",
          headers: {
            Authorization: `PortOne ${secret}`,
            "User-Agent": USER_AGENT
          },
          body: requestBody
        }
      );
      if (!response.ok) {
        throw new ModifyEscrowLogisticsError(await response.json());
      }
      return response.json();
    },
    confirmEscrow: async (options) => {
      const {
        paymentId,
        storeId,
        fromStore
      } = options;
      const requestBody = JSON.stringify({
        storeId: storeId ?? init.storeId,
        fromStore
      });
      const response = await fetch(
        new URL(`/payments/${encodeURIComponent(paymentId)}/escrow/complete`, baseUrl),
        {
          method: "POST",
          headers: {
            Authorization: `PortOne ${secret}`,
            "User-Agent": USER_AGENT
          },
          body: requestBody
        }
      );
      if (!response.ok) {
        throw new ConfirmEscrowError(await response.json());
      }
      return response.json();
    },
    resendWebhook: async (options) => {
      const {
        paymentId,
        storeId,
        webhookId
      } = options;
      const requestBody = JSON.stringify({
        storeId: storeId ?? init.storeId,
        webhookId
      });
      const response = await fetch(
        new URL(`/payments/${encodeURIComponent(paymentId)}/resend-webhook`, baseUrl),
        {
          method: "POST",
          headers: {
            Authorization: `PortOne ${secret}`,
            "User-Agent": USER_AGENT
          },
          body: requestBody
        }
      );
      if (!response.ok) {
        throw new ResendWebhookError(await response.json());
      }
      return response.json();
    },
    registerStoreReceipt: async (options) => {
      const {
        paymentId,
        items,
        storeId
      } = options;
      const requestBody = JSON.stringify({
        items,
        storeId: storeId ?? init.storeId
      });
      const response = await fetch(
        new URL(`/payments/${encodeURIComponent(paymentId)}/register-store-receipt`, baseUrl),
        {
          method: "POST",
          headers: {
            Authorization: `PortOne ${secret}`,
            "User-Agent": USER_AGENT
          },
          body: requestBody
        }
      );
      if (!response.ok) {
        throw new RegisterStoreReceiptError(await response.json());
      }
      return response.json();
    },
    billingKey: BillingKeyClient(init),
    cashReceipt: CashReceiptClient(init),
    paymentSchedule: PaymentScheduleClient(init),
    promotion: PromotionClient(init)
  };
}
export class PreRegisterPaymentError extends PaymentError {
  /** @ignore */
  constructor(data) {
    super(data);
    Object.setPrototypeOf(this, PreRegisterPaymentError.prototype);
    this.name = "PreRegisterPaymentError";
  }
}
export class GetPaymentError extends PaymentError {
  /** @ignore */
  constructor(data) {
    super(data);
    Object.setPrototypeOf(this, GetPaymentError.prototype);
    this.name = "GetPaymentError";
  }
}
export class GetPaymentsError extends PaymentError {
  /** @ignore */
  constructor(data) {
    super(data);
    Object.setPrototypeOf(this, GetPaymentsError.prototype);
    this.name = "GetPaymentsError";
  }
}
export class GetAllPaymentsError extends PaymentError {
  /** @ignore */
  constructor(data) {
    super(data);
    Object.setPrototypeOf(this, GetAllPaymentsError.prototype);
    this.name = "GetAllPaymentsError";
  }
}
export class CancelPaymentError extends PaymentError {
  /** @ignore */
  constructor(data) {
    super(data);
    Object.setPrototypeOf(this, CancelPaymentError.prototype);
    this.name = "CancelPaymentError";
  }
}
export class PayWithBillingKeyError extends PaymentError {
  /** @ignore */
  constructor(data) {
    super(data);
    Object.setPrototypeOf(this, PayWithBillingKeyError.prototype);
    this.name = "PayWithBillingKeyError";
  }
}
export class PayInstantlyError extends PaymentError {
  /** @ignore */
  constructor(data) {
    super(data);
    Object.setPrototypeOf(this, PayInstantlyError.prototype);
    this.name = "PayInstantlyError";
  }
}
export class CloseVirtualAccountError extends PaymentError {
  /** @ignore */
  constructor(data) {
    super(data);
    Object.setPrototypeOf(this, CloseVirtualAccountError.prototype);
    this.name = "CloseVirtualAccountError";
  }
}
export class ApplyEscrowLogisticsError extends PaymentError {
  /** @ignore */
  constructor(data) {
    super(data);
    Object.setPrototypeOf(this, ApplyEscrowLogisticsError.prototype);
    this.name = "ApplyEscrowLogisticsError";
  }
}
export class ModifyEscrowLogisticsError extends PaymentError {
  /** @ignore */
  constructor(data) {
    super(data);
    Object.setPrototypeOf(this, ModifyEscrowLogisticsError.prototype);
    this.name = "ModifyEscrowLogisticsError";
  }
}
export class ConfirmEscrowError extends PaymentError {
  /** @ignore */
  constructor(data) {
    super(data);
    Object.setPrototypeOf(this, ConfirmEscrowError.prototype);
    this.name = "ConfirmEscrowError";
  }
}
export class ResendWebhookError extends PaymentError {
  /** @ignore */
  constructor(data) {
    super(data);
    Object.setPrototypeOf(this, ResendWebhookError.prototype);
    this.name = "ResendWebhookError";
  }
}
export class RegisterStoreReceiptError extends PaymentError {
  /** @ignore */
  constructor(data) {
    super(data);
    Object.setPrototypeOf(this, RegisterStoreReceiptError.prototype);
    this.name = "RegisterStoreReceiptError";
  }
}
